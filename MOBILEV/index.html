<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Card Grid Builder</title>

<!-- Retro banner font -->
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<style>
/* ========== Layout & Canvas ========== */
body {
  font-family: system-ui, sans-serif;
  background: #f3f4f6;
  color: #111827;
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 0;
  padding: 20px;
}
.main {
  display: flex;
  gap: 24px;
  align-items: flex-start;
  justify-content: center;
  width: 100%;
  max-width: 1100px;
}

.game-wrapper {
  position: relative;
  width: 560px;
  height: 560px;
}
canvas {
  background: #fff;
  box-shadow: 0 6px 18px rgba(0,0,0,0.1);
  border-radius: 8px;
  cursor: pointer;
}

/* Canvas-only fade overlay */
#fade {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  background: #000;
  opacity: 0;
  pointer-events: none;
  transition: opacity 1.2s ease;
  border-radius: 8px;
  z-index: 10;
}

/* Rarity / blackout / encounter banner in middle of screen */
#rarityBanner {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 10px 18px;
  background: rgba(0, 0, 0, 0.80);
  color: white;
  font-family: "Press Start 2P", monospace;
  font-size: 14px;
  border-radius: 6px;
  opacity: 0;
  pointer-events: none;
  z-index: 20;
  transition: opacity 0.3s ease;
  white-space: nowrap;
  text-shadow: 0px 2px 0px rgba(0,0,0,0.9);
}

/* ========== Collection Panel ========== */
.collection-panel {
  width: 120px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.collection-title {
  text-align: center;
  font-weight: 700;
  font-size: 14px;
  background: #fff;
  padding: 6px 8px;
  border-radius: 8px;
  box-shadow: 0 3px 8px rgba(0,0,0,0.1);
}
.collection-grid {
  background: #fff;
  padding: 8px;
  border-radius: 8px;
  box-shadow: 0 3px 8px rgba(0,0,0,0.1);
  display: flex;
  flex-direction: column;
  gap: 6px;
  align-items: center;
}
.collection-slot {
  width: 48px;
  height: 48px;
  border-radius: 6px;
  border: 1px solid #d1d5db;
  background: #e5e7eb;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.4);
}
.collection-slot.empty {
  background:
    linear-gradient(135deg,
      #e5e7eb 25%, #f3f4f6 25%,
      #f3f4f6 50%, #e5e7eb 50%,
      #e5e7eb 75%, #f3f4f6 75%,
      #f3f4f6 100%);
  background-size: 8px 8px;
}
.collection-slot img {
  width: 40px;
  height: 40px;
  object-fit: contain;
  image-rendering: pixelated;
}
.collection-qty {
  position: absolute;
  right: 0px;
  bottom: 0px;
  background: rgba(0,0,0,0.75);
  color: white;
  font-size: 12px;
  padding: 2px 4px;
  border-top-left-radius: 6px;
}

/* ========== Sidebar UI ========== */
.ui {
  display: flex;
  flex-direction: column;
  gap: 12px;
  width: 300px;
}

/* ART BOX */
.tile-art-box {
  position: relative;
  background: #fff;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 3px 8px rgba(0,0,0,0.1);
  text-align: center;
}
.tile-art-box::before {
  content: "";
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 90px;
  background: radial-gradient(rgba(0,0,0,0.15), transparent);
  pointer-events: none;
  z-index: 1;
}
.tile-art-box img.tile-main {
  display: block;
  width: 100%;
  height: auto;
  object-fit: contain;
  background: #f9fafb;
  border-bottom: 1px solid #e5e7eb;
  position: relative;
  z-index: 0;
}

/* Item / monster sprite overlay inside art box */
.tile-art-box img.item-overlay {
  position: absolute;
  top: 52%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 72px;
  height: 72px;
  object-fit: contain;
  pointer-events: none;
  background: transparent;
  image-rendering: pixelated;
  z-index: 2;
  display: none;
}

/* Monster HP bubble & name, inside art box */
.monster-hp {
  position: absolute;
  top: 18%;
  left: 50%;
  transform: translateX(-50%);
  padding: 3px 6px;
  background: rgba(255,255,255,0.85);
  border: 1px solid rgba(0,0,0,0.2);
  border-radius: 12px;
  font-size: 12px;
  font-weight: 700;
  color: #ef4444;
  z-index: 4;
  pointer-events: none;
  white-space: nowrap;
  display: none;
}
.monster-name {
  position: absolute;
  top: 70%;
  left: 50%;
  transform: translateX(-50%);
  padding: 4px 8px;
  background: rgba(255,255,255,0.75);
  border-radius: 4px;
  font-size: 13px;
  font-weight: 700;
  z-index: 3;
  pointer-events: none;
  white-space: nowrap;
  display: none;
}

/* Rarity badge in art box bottom-left */
.rarity-badge {
  position: absolute;
  left: 14px;
  bottom: 10px;
  z-index: 5;
  pointer-events: none;

  padding: 4px 10px;
  border-radius: 999px;
  font-size: 13px;
  font-weight: 700;
  white-space: nowrap;
  box-shadow: 0 2px 4px rgba(0,0,0,0.25);
  display: none;
}
.rarity-common {
  background: #fef3c7;
  color: #92400e;
}
.rarity-uncommon {
  background: #e5e7eb;
  color: #374151;
}
.rarity-rare {
  background: #fef9c3;
  color: #854d0e;
}
/* Neutral for Home / special */
.rarity-neutral {
  background: #e5e7eb;
  color: #374151;
}

/* ACTION BOX */
.tile-actions-box {
  background: #fff;
  border-radius: 8px;
  box-shadow: 0 3px 8px rgba(0,0,0,0.1);
  padding: 8px 12px 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: center;
  min-height: 40px;
}
.tile-actions-box button {
  background: #f3f4f6;
  border: none;
  border-radius: 6px;
  padding: 6px 10px;
  cursor: pointer;
  font-weight: 600;
  width: 90%;
  transition: background .2s;
}
.tile-actions-box button:hover {
  background: #d1fae5;
}
.end-day-btn {
  background: #fde68a;
  color: #78350f;
  font-weight: 700;
}
.end-day-btn:hover {
  background: #fcd34d;
}

/* ========== Cards ========== */
.card-bar {
  margin-top: 20px;
  width: 100%;
  max-width: 1100px;
  display: flex;
  justify-content: center;
  gap: 12px;
  flex-wrap: wrap;
}
.card {
  position: relative;
  width: 100px;
  height: 140px;
  overflow: hidden;
  background: #fafafa;
  border-radius: 10px;
  box-shadow: 0 3px 8px rgba(0,0,0,0.15);
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  cursor: pointer;
  transition: transform .15s, background .15s;
}
.card.highlighted {
  transform: scale(1.1);
  background: #d1fae5;
  border: 2px solid #10b981;
}
.card img {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  opacity: .9;
  z-index: 0;
}
.card .label {
  position: relative;
  z-index: 1;
  background: rgba(255,255,255,.85);
  text-align: center;
  font-size: 13px;
  font-weight: 600;
  padding: 4px 0;
  border-top: 1px solid rgba(0,0,0,.1);
}
.card .qty-badge {
  position: absolute;
  top: 6px;
  right: 6px;
  z-index: 2;
  background: rgba(0,0,0,0.80);
  color: #fff;
  font-size: 12px;
  padding: 2px 6px;
  border-radius: 999px;
  pointer-events: none;
}

/* ========= MONSTER OVERLAY SYSTEM ========= */

/* idle glow */
.monster-idle {
  animation: monsterIdlePulse 2.6s ease-in-out infinite;
}
@keyframes monsterIdlePulse {
  0%   { transform: translate(-50%, -50%) scale(1); }
  50%  { transform: translate(-50%, -50%) scale(1.05); }
  100% { transform: translate(-50%, -50%) scale(1); }
}

/* attack lunge + flash */
.monster-attack {
  transform: translate(-50%, -50%) scale(1.18);
  filter: brightness(1.35);
  transition: transform 0.12s ease, filter 0.12s ease;
}

/* death fade */
.monster-death {
  animation: monsterDeathFade 0.26s ease forwards;
}
@keyframes monsterDeathFade {
  0%   { opacity: 1;   transform: translate(-50%, -50%) scale(1);   }
  100% { opacity: 0;   transform: translate(-50%, -50%) scale(0.45); }
}

/* art box shake on hit */
.artbox-shake {
  animation: artBoxShake 0.18s ease;
}
@keyframes artBoxShake {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-3px); }
  50%  { transform: translateX(3px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}


/* Monster modern hit flash */
.monster-hit-flash {
  filter: brightness(1.7) contrast(1.25) saturate(1.5);
  transition: filter 0.12s ease;
}


</style>
</head>

<body>

<div class="main">

  <!-- Collection panel -->
  <div class="collection-panel">
    <div class="collection-title">Collection</div>
    <div class="collection-grid" id="collectionGrid"></div>
  </div>

  <div class="game-wrapper">
    <canvas id="game" width="560" height="560"></canvas>
    <div id="fade"></div>
    <div id="rarityBanner"></div>
  </div>

  <div class="ui">
    <!-- ART BOX -->
    <div class="tile-art-box" id="tileArtBox">
      <img src="images/hometile.png" id="tileImage" class="tile-main">
      <img src="" id="itemOverlay" class="item-overlay">
      <div id="monsterHpBubble" class="monster-hp"></div>
      <div id="monsterNameTag" class="monster-name"></div>
      <div id="raritySidebarBadge" class="rarity-badge"></div>
    </div>

    <!-- ACTION BOX -->
    <div class="tile-actions-box" id="tileActions"></div>
  </div>

</div>

<div class="card-bar" id="cardContainer"></div>

<script>
/* ============================================================
   SETUP & STATE
============================================================ */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const fade = document.getElementById("fade");
const collectionGrid = document.getElementById("collectionGrid");
const tileImage = document.getElementById("tileImage");
const itemOverlay = document.getElementById("itemOverlay");
const cardContainer = document.getElementById("cardContainer");
const tileArtBox = document.getElementById("tileArtBox");
const tileActions = document.getElementById("tileActions");
const monsterHpBubble = document.getElementById("monsterHpBubble");
const monsterNameTag = document.getElementById("monsterNameTag");
const raritySidebarBadge = document.getElementById("raritySidebarBadge");

const gridSize = 7;
const tileSize = canvas.width / gridSize;
const MAX_HEALTH = 10;

const player = {
  x: Math.floor(gridSize/2),
  y: Math.floor(gridSize/2),
  animX: 0,
  animY: 0,
  targetX: 0,
  targetY: 0,
  animating: false
};

let selectedCardKey = null;
let validTiles = [];
let health = MAX_HEALTH;
let day = 1; // internal only, not shown
let tileItems = [];     // items, monsters & planted seeds on tiles
let placementAnimations = [];
let isCrafting = false;

let collectionSlots = [
  { type: "seed_common", img: "item_seed_common.png", qty: 5 },
  null,
  null,
  null,
  null,
  null,
  null
];

/* Card inventory = starter + crafted cards (no costs) */
let cardInventory = [
  { key: "PlainsPlus", qty: 10 } // starter card that always places PlainsA
];

/* ============================================================
   CARD TYPES & RECIPES
============================================================ */
const cardTypes = {
  Plains: {
    key: "Plains",
    name: "Plains",
    img: "images/card_plains.png",
    recipe: [ { item: "grass", qty: 2 } ]
  },
  Forest: {
    key: "Forest",
    name: "Forest",
    img: "images/card_forest.png",
    recipe: [
      { item: "grass", qty: 1 },
      { item: "startoken", qty: 1 }
    ]
  },
  Hills: {
    key: "Hills",
    name: "Hills",
    img: "images/card_hills.png",
    recipe: [ { item: "startoken", qty: 2 } ]
  },
  // Starter-only card, cannot be crafted
  PlainsPlus: {
    key: "PlainsPlus",
    name: "Plains+",
    img: "images/card_plains.png",
    recipe: null
  }
};

/* ============================================================
   TILE DATA (NO desc properties)
============================================================ */
const tileData = {
  Home: {
    biome: "Home",
    rarity: "special",
    gridImg: "images/hometile.png",
    img: "images/hometile.png",
    actions: ["Craft"],
    eventChance: 0,
    eventItem: null
  },

  // Plains variants - all use plains_a sprite on grid
  PlainsA: {
    biome: "Plains",
    rarity: "common",
    gridImg: "images/plains_a.png",
    img: "images/plains_a.png",
    actions: [],
    eventChance: 0.50,
    eventItem: "item_grass.png",
    monsterChance: 0.20,
    monsters: ["PinkRabbit"]
  },
  PlainsB: {
    biome: "Plains",
    rarity: "uncommon",
    gridImg: "images/plains_a.png",
    img: "images/plains_b.png",
    actions: [],
    eventChance: 1.00,
    eventItem: "item_startoken.png",
    monsterChance: 0.20,
    monsters: ["PinkRabbit"]
  },
  PlainsC: {
    biome: "Plains",
    rarity: "rare",
    gridImg: "images/plains_a.png",
    img: "images/plains_c.png",
    actions: [],
    eventChance: 0.00,
    eventItem: "item_startoken.png",
    monsterChance: 0.20,
    monsters: ["PinkRabbit"]
  },

  // Forest variants - all use forest_a sprite on grid
  ForestA: {
    biome: "Forest",
    rarity: "common",
    gridImg: "images/forest_a.png",
    img: "images/forest_a.png",
    actions: [],
    eventChance: 0.10,
    eventItem: "item_startoken.png",
    monsterChance: 0.20,
    monsters: ["Mushcap"]
  },
  ForestB: {
    biome: "Forest",
    rarity: "uncommon",
    gridImg: "images/forest_a.png",
    img: "images/forest_b.png",
    actions: [],
    eventChance: 0.15,
    eventItem: "item_startoken.png",
    monsterChance: 0.20,
    monsters: ["Mushcap"]
  },
  ForestC: {
    biome: "Forest",
    rarity: "rare",
    gridImg: "images/forest_a.png",
    img: "images/forest_c.png",
    actions: [],
    eventChance: 0.05,
    eventItem: "item_startoken.png",
    monsterChance: 0.20,
    monsters: ["Mushcap"]
  },

  // Hills variants - all use hills_a sprite on grid
  HillsA: {
    biome: "Hills",
    rarity: "common",
    gridImg: "images/hills_a.png",
    img: "images/hills_a.png",
    actions: [],
    eventChance: 0.05,
    eventItem: "item_startoken.png",
    monsterChance: 0.20,
    monsters: ["Spinehog"]
  },
  HillsB: {
    biome: "Hills",
    rarity: "uncommon",
    gridImg: "images/hills_a.png",
    img: "images/hills_b.png",
    actions: [],
    eventChance: 0.08,
    eventItem: "item_startoken.png",
    monsterChance: 0.20,
    monsters: ["Spinehog"]
  },
  HillsC: {
    biome: "Hills",
    rarity: "rare",
    gridImg: "images/hills_a.png",
    img: "images/hills_c.png",
    actions: [],
    eventChance: 0.02,
    eventItem: "item_startoken.png",
    monsterChance: 0.20,
    monsters: ["Spinehog"]
  },

  blank: {
    biome: "None",
    rarity: null,
    gridImg: "",
    img: "",
    actions: [],
    eventChance: 0,
    eventItem: null
  }
};

/* Rarity border colors for grid */
const rarityColors = {
  common:   "#8a5a37", // bronze / brown
  uncommon: "#c0c0c0", // silver
  rare:     "#ffd700", // gold
  special:  "#00c8b4"  // teal / blue-green (not used in badge)
};

/* ============================================================
   MONSTERS
============================================================ */
const monsterData = {
  PinkRabbit: {
    name: "Pink Rabbit",
    hp: 3,
    atk: 1,
    img: "monsters/monster_pink_rabbit.png"
  },
  Mushcap: {
    name: "Mushcap",
    hp: 5,
    atk: 2,
    img: "monsters/monster_mushcap.png"
  },
  Spinehog: {
    name: "Spinehog",
    hp: 7,
    atk: 2,
    img: "monsters/monster_spinehog.png"
  }
};

/* ============================================================
   SEED GROWTH TABLES
============================================================ */
const SEED_GROWTH = {
  Plains: {
    common: [
      { type: "sprout",      img: "item_sprout.png",      chance: 0.60 },
      { type: "herb",        img: "item_herb.png",        chance: 0.35 },
      { type: "blossom",     img: "item_blossom.png",     chance: 0.15 }
    ],
    uncommon: [
      { type: "herb",        img: "item_herb.png",        chance: 0.60 },
      { type: "blossom",     img: "item_blossom.png",     chance: 0.35 },
      { type: "crystal",     img: "item_crystal_bud.png", chance: 0.15 }
    ],
    rare: [
      { type: "blossom",     img: "item_blossom.png",     chance: 0.60 },
      { type: "crystal",     img: "item_crystal_bud.png", chance: 0.35 },
      { type: "goldenfruit", img: "item_goldenfruit.png", chance: 0.15 }
    ]
  },
  Forest: {
    common: [
      { type: "sprout",      img: "item_sprout.png",      chance: 0.60 },
      { type: "herb",        img: "item_herb.png",        chance: 0.35 },
      { type: "blossom",     img: "item_blossom.png",     chance: 0.15 }
    ],
    uncommon: [
      { type: "herb",        img: "item_herb.png",        chance: 0.60 },
      { type: "blossom",     img: "item_blossom.png",     chance: 0.35 },
      { type: "crystal",     img: "item_crystal_bud.png", chance: 0.15 }
    ],
    rare: [
      { type: "blossom",     img: "item_blossom.png",     chance: 0.60 },
      { type: "crystal",     img: "item_crystal_bud.png", chance: 0.35 },
      { type: "goldenfruit", img: "item_goldenfruit.png", chance: 0.15 }
    ]
  }
};

/* Preload grid sprites */
const tileGridImages = {};
for (let key in tileData) {
  const src = tileData[key].gridImg;
  if (src) {
    const img = new Image();
    img.src = src;
    tileGridImages[key] = img;
  }
}

const playerImg = new Image();
playerImg.src = "images/player.png";

/* ============================================================
   GRID INITIALIZE
============================================================ */
const grid = Array.from({length: gridSize}, () => Array(gridSize).fill("blank"));
grid[player.y][player.x] = "Home";

/* ============================================================
   PLAYER MOVEMENT ANIMATION
============================================================ */
function animatePlayerTo(newX, newY) {
  if (player.animating) return;

  player.animX = player.x * tileSize;
  player.animY = player.y * tileSize;
  player.targetX = newX * tileSize;
  player.targetY = newY * tileSize;
  player.animating = true;

  const duration = 120;
  const startTime = performance.now();

  function step(now) {
    let t = (now - startTime) / duration;
    if (t > 1) t = 1;

    player.animX = player.x * tileSize + (newX - player.x) * tileSize * t;
    player.animY = player.y * tileSize + (newY - player.y) * tileSize * t;

    drawGrid();

    if (t < 1) {
      requestAnimationFrame(step);
    } else {
      player.x = newX;
      player.y = newY;
      player.animating = false;
      drawGrid();
      updateTileInfo();
    }
  }

  requestAnimationFrame(step);
}

/* ============================================================
   COLLECTION RENDER
============================================================ */
function renderCollection() {
  collectionGrid.innerHTML = "";
  collectionSlots.forEach(slot => {
    const div = document.createElement("div");
    div.className = "collection-slot" + (slot ? "" : " empty");

    if (slot) {
      const img = document.createElement("img");
      img.src = "images/" + slot.img;
      div.appendChild(img);

      const qty = document.createElement("div");
      qty.className = "collection-qty";
      qty.textContent = "×" + slot.qty;
      div.appendChild(qty);
    }
    collectionGrid.appendChild(div);
  });
}

/* ============================================================
   BLACKOUT MESSAGE (player HP reaches 0)
============================================================ */
function showBlackoutMessage(callback) {
  const banner = document.getElementById("rarityBanner");

  banner.innerHTML = `
    <span style="color:#ff7171; font-weight:800;">You blacked out!</span>
  `;

  banner.style.transition = "none";
  banner.style.opacity = 0;
  void banner.offsetWidth;
  banner.style.transition = "opacity 0.3s ease";
  banner.style.opacity = 1;

  setTimeout(() => {
    banner.style.opacity = 0;
    setTimeout(callback, 400);
  }, 1300);
}

/* ============================================================
   PLACEMENT ANIMATION
============================================================ */
function triggerPlacementAnimation(x, y) {
  const stages = [0, 1, 2, 3];
  stages.forEach((stage, i) => {
    setTimeout(() => {
      placementAnimations = placementAnimations.filter(a => !(a.x === x && a.y === y));
      if (stage < 3) placementAnimations.push({ x, y, stage });
      drawGrid();
    }, i * 55);
  });
}

/* ============================================================
   RARITY BANNER (tile discovered)
============================================================ */
let rarityBannerTimeout = null;

function showRarityBanner(rarity, biome) {
  const banner = document.getElementById("rarityBanner");
  const color = rarityColors[rarity] || "#ffffff";

  const rarityWord = rarity.charAt(0).toUpperCase() + rarity.slice(1);
  const msg = `
    A <span style="color:${color}; font-weight:800;">${rarityWord}</span> ${biome} has been discovered!
  `;

  banner.innerHTML = msg;

  if (rarityBannerTimeout) {
    clearTimeout(rarityBannerTimeout);
    rarityBannerTimeout = null;
  }

  banner.style.transition = "none";
  banner.style.opacity = 0;
  void banner.offsetWidth;
  banner.style.transition = "opacity 0.3s ease";

  banner.style.opacity = 1;

  rarityBannerTimeout = setTimeout(() => {
    banner.style.opacity = 0;
  }, 1400);
}

/* ============================================================
   MONSTER ENCOUNTER BANNER
============================================================ */
function showMonsterAppearMessage(name) {
  const banner = document.getElementById("rarityBanner");

  banner.innerHTML = `
    <span style="color:#ffd480; font-weight:800;">${name} appeared!</span>
  `;

  banner.style.transition = "none";
  banner.style.opacity = 0;
  void banner.offsetWidth;
  banner.style.transition = "opacity 0.25s ease";

  banner.style.opacity = 1;

  setTimeout(() => {
    banner.style.opacity = 0;
  }, 1200);
}

/* ============================================================
   DRAW GRID + PLAYER HP BUBBLE
============================================================ */
function drawGrid() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const t = grid[y][x];
      const tx = x * tileSize, ty = y * tileSize;
      const d = tileData[t];

      if (tileGridImages[t]) {
        ctx.drawImage(tileGridImages[t], tx, ty, tileSize, tileSize);
      } else {
        const s = tileSize / 6;
        for (let a = 0; a < 6; a++) {
          for (let b = 0; b < 6; b++) {
            ctx.fillStyle = ((a + b) % 2 === 0)
              ? "rgba(230,232,236,0.6)"
              : "rgba(210,212,216,0.6)";
            ctx.fillRect(tx + a * s, ty + b * s, s, s);
          }
        }
      }

      // inner borders
      ctx.strokeStyle = "rgba(0,0,0,0.25)";
      ctx.strokeRect(tx + 0.5, ty + 0.5, tileSize - 1, tileSize - 1);

      ctx.strokeStyle = "rgba(255,255,255,0.2)";
      ctx.strokeRect(tx + 3, ty + 3, tileSize - 6, tileSize - 6);

      // rarity border (not for special)
      if (d && d.rarity && d.rarity !== "special") {
        ctx.save();
        ctx.strokeStyle = rarityColors[d.rarity];
        ctx.globalAlpha = 0.55;
        ctx.lineWidth = 4;
        ctx.strokeRect(tx + 3, ty + 3, tileSize - 6, tileSize - 6);
        ctx.restore();
      }

      // highlight valid placement tiles
      if (validTiles.some(v => v.x === x && v.y === y)) {
        const grd = ctx.createLinearGradient(tx, ty, tx + tileSize, ty + tileSize);
        grd.addColorStop(0, "rgba(255, 230, 140, 0.20)");
        grd.addColorStop(1, "rgba(255, 210, 120, 0.35)");

        ctx.save();
        ctx.fillStyle = grd;
        ctx.fillRect(tx + 2, ty + 2, tileSize - 4, tileSize - 4);

        ctx.strokeStyle = "rgba(255, 220, 140, 0.9)";
        ctx.lineWidth = 3;
        ctx.strokeRect(tx + 3, ty + 3, tileSize - 6, tileSize - 6);
        ctx.restore();
      }

      const anim = placementAnimations.find(a => a.x === x && a.y === y);
      if (anim) {
        const flashAlpha = [0.9, 0.6, 0.3][anim.stage];
        const flashInset = [1, 3, 5][anim.stage];
        const flashWidth = [6, 4, 2][anim.stage];

        ctx.save();
        ctx.strokeStyle = `rgba(255,255,200,${flashAlpha})`;
        ctx.lineWidth = flashWidth;
        ctx.strokeRect(
          tx + flashInset,
          ty + flashInset,
          tileSize - flashInset * 2,
          tileSize - flashInset * 2
        );
        ctx.restore();

        const glowAlpha = [0.5, 0.35, 0.15][anim.stage];
        ctx.save();
        ctx.strokeStyle = `rgba(255,255,180,${glowAlpha})`;
        ctx.lineWidth = 8;
        ctx.strokeRect(tx - 4, ty - 4, tileSize + 8, tileSize + 8);
        ctx.restore();
      }
    }
  }

  // Draw player
  const px = player.animating ? player.animX : player.x * tileSize;
  const py = player.animating ? player.animY : player.y * tileSize;

  ctx.drawImage(playerImg, px, py, tileSize, tileSize);
  drawStatBubble(px + tileSize / 2, py + 6);
}

/* ============================================================
   STAT BUBBLE (HP ONLY)
============================================================ */
function drawStatBubble(cx, cy) {
  const txt = `❤️ ${health}`;
  ctx.font = "16px system-ui";
  const tw = ctx.measureText(txt).width;
  const pad = 8, w = tw + pad * 2, h = 26, x = cx - w / 2, y = cy - h;

  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.strokeStyle = "rgba(229,231,235,0.9)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.roundRect(x, y, w, h, 12);
  ctx.fill();
  ctx.stroke();
  ctx.restore();

  ctx.textBaseline = "middle";
  ctx.fillStyle = "#ef4444";
  ctx.fillText(txt, x + pad, y + h / 2);
}

/* ============================================================
   HELPERS
============================================================ */
function findValidTiles() {
  const dirs = [
    { x: 0, y: -1 },
    { x: 0, y: 1 },
    { x: -1, y: 0 },
    { x: 1, y: 0 }
  ];
  return dirs
    .map(d => ({ x: player.x + d.x, y: player.y + d.y }))
    .filter(t =>
      t.x >= 0 && t.y >= 0 &&
      t.x < gridSize && t.y < gridSize &&
      grid[t.y][t.x] === "blank"
    );
}

function wPlains() {
  const r = Math.random();
  return r < 0.65 ? "PlainsA" : r < 0.9 ? "PlainsB" : "PlainsC";
}
function wForest() {
  const r = Math.random();
  return r < 0.65 ? "ForestA" : r < 0.9 ? "ForestB" : "ForestC";
}
function wHills() {
  const r = Math.random();
  return r < 0.65 ? "HillsA" : r < 0.9 ? "HillsB" : "HillsC";
}

/* Item helpers */
function getTotalItemCount(type) {
  return collectionSlots.reduce(
    (sum, slot) => (slot && slot.type === type ? sum + slot.qty : sum),
    0
  );
}

function canCraft(cardType) {
  if (!cardType.recipe || !cardType.recipe.length) return false;
  return cardType.recipe.every(req => getTotalItemCount(req.item) >= req.qty);
}

function consumeItems(recipe) {
  recipe.forEach(req => {
    let remaining = req.qty;
    for (let i = 0; i < collectionSlots.length && remaining > 0; i++) {
      const slot = collectionSlots[i];
      if (slot && slot.type === req.item) {
        const used = Math.min(slot.qty, remaining);
        slot.qty -= used;
        remaining -= used;
        if (slot.qty === 0) collectionSlots[i] = null;
      }
    }
  });
}

function consumeOneItem(type) {
  for (let i = 0; i < collectionSlots.length; i++) {
    const slot = collectionSlots[i];
    if (slot && slot.type === type) {
      slot.qty -= 1;
      if (slot.qty <= 0) collectionSlots[i] = null;
      break;
    }
  }
  renderCollection();
}

function addCardToInventory(key) {
  const existing = cardInventory.find(e => e.key === key);
  if (existing) existing.qty++;
  else cardInventory.push({ key, qty: 1 });
}

/* Seed growth helper */
function rollSeedGrowth(biome, rarity) {
  const tableBiome = SEED_GROWTH[biome];
  if (!tableBiome) return null;
  const table = tableBiome[rarity];
  if (!table || !table.length) return null;

  const roll = Math.random();
  let acc = 0;
  for (const row of table) {
    acc += row.chance;
    if (roll <= acc) {
      return { type: row.type, img: row.img };
    }
  }
  return table[table.length - 1];
}

/* Floating rarity badge helper */
function updateSidebarRarityBadge(d) {
  if (!d) {
    raritySidebarBadge.style.display = "none";
    return;
  }

  const biomeName = d.biome || "";
  let text = biomeName;
  let rarityClass = "rarity-neutral";

  if (d.biome === "Home") {
    text = "Home";
    rarityClass = "rarity-neutral";
  } else if (d.rarity && d.rarity !== "special") {
    const rarityWord = d.rarity.charAt(0).toUpperCase() + d.rarity.slice(1);
    text = `${rarityWord} ${biomeName}`;
    rarityClass = `rarity-${d.rarity}`;
  }

  raritySidebarBadge.className = `rarity-badge ${rarityClass}`;
  raritySidebarBadge.textContent = text;
  raritySidebarBadge.style.display = "inline-block";
}

/* ============================================================
   CARDS (RENDER + USE)
============================================================ */
function renderCards() {
  cardContainer.innerHTML = "";

  cardInventory.forEach(entry => {
    const type = cardTypes[entry.key];
    if (!type) return;

    const div = document.createElement("div");
    div.className = "card" + (entry.key === selectedCardKey ? " highlighted" : "");

    div.innerHTML = `
      <img src="${type.img}">
      <div class="label">${type.name}</div>
      <div class="qty-badge">×${entry.qty}</div>
    `;

    div.onclick = () => {
      if (selectedCardKey === entry.key) {
        selectedCardKey = null;
        validTiles = [];
        renderCards();
        drawGrid();
        return;
      }

      selectedCardKey = entry.key;
      validTiles = findValidTiles();
      renderCards();
      drawGrid();
    };

    cardContainer.appendChild(div);
  });
}

/* ============================================================
   TILE PLACEMENT
============================================================ */
canvas.onclick = e => {
  if (!selectedCardKey) return;

  const type = cardTypes[selectedCardKey];
  if (!type) return;

  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left) / tileSize);
  const y = Math.floor((e.clientY - rect.top) / tileSize);

  const ok = validTiles.some(t => t.x === x && t.y === y);
  if (!ok) return;

  if (type.key === "Plains") {
    grid[y][x] = wPlains();
  } else if (type.key === "PlainsPlus") {
    grid[y][x] = "PlainsA";
  } else if (type.key === "Forest") {
    grid[y][x] = wForest();
  } else if (type.key === "Hills") {
    grid[y][x] = wHills();
  } else {
    grid[y][x] = type.key;
  }

  triggerPlacementAnimation(x, y);

  const placedTile = grid[y][x];
  const placedData = tileData[placedTile];

  if (placedData && placedData.rarity && placedData.rarity !== "special") {
    showRarityBanner(placedData.rarity, placedData.biome);
  }

  const entryIndex = cardInventory.findIndex(e2 => e2.key === selectedCardKey);
  if (entryIndex !== -1) {
    cardInventory[entryIndex].qty--;
    if (cardInventory[entryIndex].qty <= 0) {
      cardInventory.splice(entryIndex, 1);
    }
  }

  selectedCardKey = null;
  validTiles = [];
  renderCards();
  updateUI();
};

/* ============================================================
   MOVEMENT (costs 1 HP, blocked by monster)
============================================================ */
document.onkeydown = e => {
  if (health <= 0 || player.animating) return;

  // Prevent movement if a monster is present on this tile
  const monsterHere = tileItems.some(i =>
    i.x === player.x &&
    i.y === player.y &&
    i.type === "monster"
  );
  if (monsterHere) return;

  let nx = player.x, ny = player.y;
  const k = e.key.toLowerCase();
  if (k === "arrowup" || k === "w") ny--;
  else if (k === "arrowdown" || k === "s") ny++;
  else if (k === "arrowleft" || k === "a") nx--;
  else if (k === "arrowright" || k === "d") nx++;
  else return;

  if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize) return;
  if (grid[ny][nx] === "blank") return;

  health = Math.max(0, health - 1);
  animatePlayerTo(nx, ny);
  updateUI();
};

/* ============================================================
   DAILY EVENT + SEED GROWTH + MONSTERS
============================================================ */
function initDailyEvents() {
  const prevTileItems = tileItems;
  tileItems = [];

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const t = grid[y][x];
      const d = tileData[t];
      if (!d) continue;

      // Seed growth from previous day
      const seed = prevTileItems.find(
        it => it.x === x && it.y === y && it.type === "planted_seed"
      );
      if (seed) {
        const grown = rollSeedGrowth(d.biome, seed.rarity);
        if (grown) {
          tileItems.push({
            x, y,
            type: grown.type,
            img: grown.img
          });
        }
        continue;
      }

      let hasEvent = false;

      // Item event
      if (d.eventChance && d.eventItem) {
        if (Math.random() < d.eventChance) {
          let type = "startoken";
          if (d.eventItem === "item_grass.png") {
            type = "grass";
          }
          tileItems.push({ x, y, type, img: d.eventItem });
          hasEvent = true;
        }
      }

      // Monster event (only if no item spawned)
      if (!hasEvent && d.monsterChance && d.monsters && d.monsters.length > 0) {
        if (Math.random() < d.monsterChance) {
          const monsterKey = d.monsters[Math.floor(Math.random() * d.monsters.length)];
          const monsterDef = monsterData[monsterKey];
          if (monsterDef) {
            tileItems.push({
              x, y,
              type: "monster",
              monsterKey,
              hp: monsterDef.hp,
              img: monsterDef.img
            });
          }
        }
      }
    }
  }
}

/* ============================================================
   MONSTER ATTACK ANIMATION
============================================================ */
function animateMonsterAttack() {
  const sprite = document.getElementById("itemOverlay");
  const artBox = document.getElementById("tileArtBox");

  // Stop idle glow during attack
  sprite.classList.remove("monster-idle");

  // Lunge forward
  sprite.classList.add("monster-attack");

  // Flash on impact
  sprite.classList.add("monster-hit-flash");

  // Remove lunge + flash
  setTimeout(() => {
    sprite.classList.remove("monster-attack");
    sprite.classList.remove("monster-hit-flash");

    // Restore idle glow
    sprite.classList.add("monster-idle");
  }, 150);

  // Shake art box
  artBox.classList.add("artbox-shake");
  setTimeout(() => {
    artBox.classList.remove("artbox-shake");
  }, 200);
}


/* ============================================================
   SIDEBAR / CRAFTING / SEEDS / MONSTERS
============================================================ */
function addEndDayButton() {
  const existing = tileActions.querySelector(".end-day-btn");
  if (existing) existing.remove();

  const t = grid[player.y][player.x];

  if (isCrafting) return;

  if (health === 0) {
    const b = document.createElement("button");
    b.textContent = "End the Day";
    b.classList.add("end-day-btn");
    b.onclick = endDay;
    tileActions.appendChild(b);
    return;
  }

  if (t === "Home" && health > 0) {
    const b = document.createElement("button");
    b.textContent = "End the Day Early";
    b.classList.add("end-day-btn");
    b.onclick = endDay;
    tileActions.appendChild(b);
  }
}

function buildCraftingMenu() {
  tileActions.innerHTML = "";

  const craftables = Object.values(cardTypes).filter(ct => ct.recipe && ct.recipe.length);

  craftables.forEach(ct => {
    const btn = document.createElement("button");

    const recipeText = "Cost: " + ct.recipe.map(r => {
      const name = r.item === "grass" ? "Grass" : "Star Token";
      return `${r.qty}× ${name}`;
    }).join(" + ");

    btn.textContent = `${ct.name} — ${recipeText}`;

    if (!canCraft(ct)) {
      btn.disabled = true;
      btn.style.opacity = "0.5";
    }

    btn.onclick = () => {
      if (!canCraft(ct)) return;
      consumeItems(ct.recipe);
      addCardToInventory(ct.key);
      renderCollection();
      renderCards();
      updateTileInfo();
    };

    tileActions.appendChild(btn);
  });

  const backBtn = document.createElement("button");
  backBtn.textContent = "Back";
  backBtn.onclick = () => {
    isCrafting = false;
    updateTileInfo();
  };
  tileActions.appendChild(backBtn);
}

/* Handle monster encounter in sidebar; returns true if handled */
function handleMonsterEncounter(found, d) {
  const monster = monsterData[found.monsterKey];
  if (!monster) {
    itemOverlay.style.display = "none";
    itemOverlay.classList.remove("monster-idle", "monster-attack", "monster-death");
    addEndDayButton();
    return true;
  }

  // sprite
  itemOverlay.src = "images/" + monster.img;
  itemOverlay.style.display = "block";
  itemOverlay.classList.add("monster-idle");

  // HP + name
  monsterHpBubble.style.display = "block";
  monsterHpBubble.textContent = `❤️ ${found.hp}`;
  monsterNameTag.style.display = "block";
  monsterNameTag.textContent = monster.name;

  // encounter banner (once)
  if (!found._appearedShown) {
    showMonsterAppearMessage(monster.name);
    found._appearedShown = true;
  }

  // Fight button
  const fightBtn = document.createElement("button");
  fightBtn.textContent = "Fight";

  fightBtn.onclick = () => {
    // PLAYER ATTACKS
    found.hp -= 1;
    monsterHpBubble.textContent = `❤️ ${found.hp}`;

    // MONSTER DIES
    if (found.hp <= 0) {
      itemOverlay.classList.remove("monster-idle");
      itemOverlay.classList.add("monster-death");
      tileActions.innerHTML = "";

      setTimeout(() => {
        itemOverlay.classList.remove("monster-death");
        itemOverlay.style.display = "none";
        tileItems = tileItems.filter(i => i !== found);
        updateTileInfo();
      }, 260);
      return;
    }

    // MONSTER COUNTERATTACKS
    health = Math.max(0, health - monster.atk);
    animateMonsterAttack();

    // BLACKOUT
    if (health <= 0) {
      updateUI();          // ensure HP bubble shows 0
      tileActions.innerHTML = "";
      showBlackoutMessage(() => {
        endDay();
      });
      return;
    }

    updateUI();
  };

  tileActions.appendChild(fightBtn);

  // Flee button
  const fleeBtn = document.createElement("button");
  fleeBtn.textContent = "Flee";
  fleeBtn.onclick = () => {
    player.x = 3;
    player.y = 3;
    updateUI();
  };
  tileActions.appendChild(fleeBtn);

  addEndDayButton();
  return true;
}

function updateTileInfo() {
  const t = grid[player.y][player.x];
  const d = tileData[t];
  if (!d) return;

  if (t !== "Home") {
    isCrafting = false;
  }

  // Reset art box
  tileImage.src = d.img || "";
  itemOverlay.style.display = "none";
  itemOverlay.classList.remove("monster-idle", "monster-attack", "monster-death");

  monsterHpBubble.style.display = "none";
  monsterNameTag.style.display = "none";

  // Always update rarity badge
  updateSidebarRarityBadge(d);

  // Reset actions
  tileActions.innerHTML = "";

  const found = tileItems.find(it => it.x === player.x && it.y === player.y);

  // MONSTER BRANCH
  if (found && found.type === "monster") {
    if (handleMonsterEncounter(found, d)) return;
  }

  // OVERLAY LOGIC (items / seeds, not monsters)
  if (found) {
    itemOverlay.src = "images/" + found.img;
    itemOverlay.style.display = "block";
    itemOverlay.classList.remove("monster-idle", "monster-attack", "monster-death");

    if (found.type === "planted_seed") {
      // just show the seed sprite
    } else {
      const btn = document.createElement("button");
      let label = "Collect Item";

      if (found.type === "grass") label = "Collect Grass";
      else if (found.type === "startoken") label = "Collect Star Token";
      else if (found.type === "sprout") label = "Collect Sprout";
      else if (found.type === "herb") label = "Collect Herb";
      else if (found.type === "blossom") label = "Collect Blossom";
      else if (found.type === "crystal") label = "Collect Crystal";
      else if (found.type === "goldenfruit") label = "Collect Golden Fruit";

      btn.textContent = label;
      btn.onclick = () => {
        let slotIndex = collectionSlots.findIndex(s => s && s.type === found.type);

        if (slotIndex !== -1) {
          collectionSlots[slotIndex].qty++;
        } else {
          let empty = collectionSlots.findIndex(s => s === null);
          if (empty === -1) return;
          collectionSlots[empty] = {
            type: found.type,
            img: found.img,
            qty: 1
          };
        }

        tileItems = tileItems.filter(i => i !== found);
        itemOverlay.style.display = "none";
        renderCollection();
        updateTileInfo();
      };
      tileActions.appendChild(btn);
    }
  } else {
    itemOverlay.style.display = "none";
  }

  // Crafting UI
  if (t === "Home" && isCrafting) {
    buildCraftingMenu();
    addEndDayButton();
    return;
  }

  // Tile actions (e.g. Craft on Home)
  if (d.actions && d.actions.length) {
    d.actions.forEach(actionName => {
      if (actionName === "Craft" && t === "Home") {
        const btn = document.createElement("button");
        btn.textContent = "Craft Cards";
        btn.onclick = () => {
          isCrafting = true;
          updateTileInfo();
        };
        tileActions.appendChild(btn);
      } else {
        const btn = document.createElement("button");
        btn.textContent = actionName;
        btn.disabled = true;
        btn.style.opacity = "0.5";
        tileActions.appendChild(btn);
      }
    });
  }

  // Seed planting
  const biome = d.biome;
  const hasTileItem = !!found;
  const canPlantHere =
    (biome === "Plains" || biome === "Forest") &&
    !hasTileItem;

  if (canPlantHere) {
    const hasCommonSeed   = getTotalItemCount("seed_common")   > 0;
    const hasUncommonSeed = getTotalItemCount("seed_uncommon") > 0;
    const hasRareSeed     = getTotalItemCount("seed_rare")     > 0;

    if (hasCommonSeed || hasUncommonSeed || hasRareSeed) {
      if (hasCommonSeed) {
        const b = document.createElement("button");
        b.textContent = "Plant Common Seed";
        b.onclick = () => {
          consumeOneItem("seed_common");
          tileItems.push({
            x: player.x,
            y: player.y,
            type: "planted_seed",
            rarity: "common",
            img: "item_seed_common.png"
          });
          updateTileInfo();
        };
        tileActions.appendChild(b);
      }

      if (hasUncommonSeed) {
        const b = document.createElement("button");
        b.textContent = "Plant Uncommon Seed";
        b.onclick = () => {
          consumeOneItem("seed_uncommon");
          tileItems.push({
            x: player.x,
            y: player.y,
            type: "planted_seed",
            rarity: "uncommon",
            img: "item_seed_uncommon.png"
          });
          updateTileInfo();
        };
        tileActions.appendChild(b);
      }

      if (hasRareSeed) {
        const b = document.createElement("button");
        b.textContent = "Plant Rare Seed";
        b.onclick = () => {
          consumeOneItem("seed_rare");
          tileItems.push({
            x: player.x,
            y: player.y,
            type: "planted_seed",
            rarity: "rare",
            img: "item_seed_rare.png"
          });
          updateTileInfo();
        };
        tileActions.appendChild(b);
      }
    }
  }

  addEndDayButton();
}

/* ============================================================
   DAY CYCLE
============================================================ */
function endDay() {
  fade.style.opacity = 1;
  setTimeout(() => {
    player.x = 3;
    player.y = 3;
    player.animX = player.x * tileSize;
    player.animY = player.y * tileSize;

    health = MAX_HEALTH;
    day++;

    initDailyEvents();
    fade.style.opacity = 0;
    updateUI();
  }, 1200);
}

/* ============================================================
   BOOT
============================================================ */
function updateUI() {
  updateTileInfo();
  drawGrid();
  renderCollection();
}

initDailyEvents();
renderCards();
updateUI();
</script>
</body>
</html>
